# SilMoポートフォリオサイト テスト戦略定義書

## 1. テスト戦略の概要

### 1.1 テストの目的

SilMoポートフォリオサイトのテスト戦略は、以下の目的を持ちます：

- **品質保証**: コードの正確性と信頼性を確保する
- **回帰テスト**: 新機能追加や修正による既存機能への影響を検出する
- **メンテナンス性向上**: 将来の機能拡張や修正を容易にする
- **技術学習**: Vitest、Storybookなどのテスト技術のスキルアップを図る

### 1.2 テスト範囲

個人開発という特性と開発効率を考慮し、以下の範囲に焦点を当てます：

- **ユーティリティ関数**: データ変換、フォーマット処理などの純粋な関数
- **カスタムフック**: 独自に実装したReactフック
- **UIコンポーネント**: 再利用性の高いUI要素や複雑なコンポーネント
- **重要なビジネスロジック**: CMS連携など、サイトの中核となる処理

### 1.3 テスト対象外

以下の項目は、コストと効果のバランスを考慮し、原則としてテスト対象から除外します：

- **E2Eテスト**: エンドツーエンドのブラウザテスト
- **レンダリング結果の詳細検証**: スタイルやレイアウトの厳密なテスト
- **サードパーティライブラリ**: 既に十分テストされたライブラリのテスト

## 2. テストの種類と手法

### 2.1 単体テスト (Vitest)

#### 2.1.1 テスト対象と優先度

**最優先（必須）**:
- 複雑なロジックを含む関数
- データ変換・操作を行うユーティリティ
- 重要なカスタムフック

**中優先**:
- API通信関連の関数
- 共通コンポーネントの主要機能
- フォームバリデーションロジック

**低優先**:
- シンプルな表示用コンポーネント
- 外部ライブラリのラッパー関数

#### 2.1.2 テスト手法

- **単純な関数テスト**: 入力と出力の検証
- **モック/スタブの活用**: 外部依存のある関数のテスト
- **React Testing Library**: コンポーネントとカスタムフックのテスト
- **スナップショットテスト**: UI変更の検出（限定的に使用）

#### 2.1.3 テスト構造

```
// 例：format-date.test.ts の構造
describe('formatDate関数', () => {
  it('正しい形式で日付をフォーマットする', () => {
    // テスト内容
  });
  
  it('無効な日付の場合はエラーをスローする', () => {
    // テスト内容
  });
});
```

#### 2.1.4 テストファイルの配置

テスト対象ファイルと同じディレクトリに直接配置し、ファイル名は`.spec.ts`の形式とします：

```
src/
  lib/
    format-date.ts
    format-date.spec.ts
  components/
    ui/
      button.tsx
      button.spec.tsx
```

### 2.2 コンポーネントテスト (Storybook)

#### 2.2.1 テスト対象と優先度

**最優先（必須）**:
- 共通UIコンポーネント（ボタン、カード、フォーム要素など）
- 複数のバリエーションを持つコンポーネント
- 頻繁に再利用されるコンポーネント

**中優先**:
- ページの主要セクション（ヘッダー、フッターなど）
- 複雑なレイアウトコンポーネント

**低優先**:
- ページ全体のストーリー
- 一度しか使用されないコンポーネント

#### 2.2.2 ストーリー作成手法

- **コンポーネントごとに複数のストーリー**: 異なる状態やバリエーションを表現
- **Controls の活用**: プロパティの動的な変更でバリエーションをテスト
- **アクセシビリティテスト**: a11y アドオンを使用した検証
- **レスポンシブ検証**: ビューポートアドオンを使用した各画面サイズでの表示確認

#### 2.2.3 ストーリー構造

各コンポーネントのストーリーファイルは以下の構造で作成します：

```
// 例：Button.stories.ts の構造
- デフォルトのストーリー
- バリエーション（プライマリ、セカンダリなど）
- 状態別（ホバー、フォーカス、無効化など）
- サイズ別（小、中、大など）
- エッジケース（長いテキスト、特殊文字など）
```

#### 2.2.4 ストーリーファイルの配置

すべてのストーリーファイルはルートディレクトリ直下の`stories`ディレクトリに統合して配置します：

```
/
  stories/
    ui/
      button.stories.tsx
    layout/
      header.stories.tsx
    pages/
      home.stories.tsx
  src/
    components/
      ui/
        button.tsx
```

## 3. Vitest実装ガイドライン

### 3.1 テストの基本原則

- **独立性**: 各テストは他のテストに依存せず独立して実行可能
- **繰り返し可能**: 何度実行しても同じ結果
- **自己完結**: テストコード自体が何をテストしているか明確
- **高速**: テスト実行は迅速に完了する

### 3.2 テスト記述スタイル

- **Arrange-Act-Assert**: 準備・実行・検証の3ステップで記述
- **明確な期待値**: 何が期待されているかを明示的に記述
- **テスト名**: テストの意図が明確にわかる命名

### 3.3 モックとスタブ

- **外部依存のモック**: APIや外部サービスは適切にモック
- **テストダブルの活用**: 時間依存処理などの制御が難しい部分はテストダブルを使用
- **モック範囲の最小化**: 必要最小限のモックにとどめる

### 3.4 Vitest設定（vitest.config.ts）

```typescript
// 設定例（具体的な実装は省略）
- テスト環境の指定
- グローバルセットアップファイルの設定
- カバレッジ設定
- モックの自動検出
- ファイル命名パターン（*.spec.ts）の指定
```

### 3.5 テストケースの粒度

テストケースは適切な粒度で分割し、以下の原則に従います：

- **単一の責務**: 各テストケースは1つの機能や動作のみを検証
- **独立した検証**: 各検証（expect）は明確に分離し、複数の検証を1つのテストケースにまとめない
- **シナリオベース**: 実際のユースケースやシナリオに基づいたテスト設計
- **境界値テスト**: 境界条件や特殊なケースを個別のテストケースとして記述
- **入力値のバリエーション**: 典型的な入力、無効な入力、極端な値など、様々な入力パターンでテスト

### 3.5 React Testing Libraryの活用

- **ユーザー中心のテスト**: 実際のユーザー操作を模した検証
- **アクセシビリティに配慮したセレクタ**: テキスト、ロール、ラベルによる要素の選択
- **ユーザーイベントのシミュレーション**: クリック、キー入力などのイベント発火

## 4. Storybook実装ガイドライン

### 4.1 ストーリー作成の基本原則

- **独立性**: 各ストーリーは独立して機能する
- **ドキュメント性**: コンポーネントの使用方法が理解できるように記述
- **網羅性**: コンポーネントの主要なバリエーションをカバー
- **再現性**: エッジケースや特殊なシナリオも含める

### 4.2 ストーリー記述スタイル

- **Component Story Format (CSF)**: 最新のストーリー記述形式を使用
- **Template パターン**: テンプレートを定義して各ストーリーで再利用
- **Args の活用**: 引数でバリエーションを表現

### 4.3 ドキュメント拡充

- **MDX の活用**: コンポーネントの詳細な説明やガイドラインを記述
- **ドキュメントページ**: 複雑なコンポーネントはドキュメントページを作成
- **Design Tokens の可視化**: カラー、スペーシング等のデザイントークンを表示

### 4.4 Storybook設定（.storybook/main.js）

```javascript
// 設定例（具体的な実装は省略）
- 標準アドオン（Controls, Actions, Viewport, a11y）の設定
- Tailwind CSSのサポート
- 静的ファイルの取り扱い
- Webpack設定のカスタマイズ
```

### 4.5 アドオンの活用

- **@storybook/addon-a11y**: アクセシビリティテスト
- **@storybook/addon-viewport**: レスポンシブデザインテスト
- **@storybook/addon-interactions**: インタラクションテスト
- **@storybook/addon-controls**: プロパティの動的変更
- **@storybook/addon-docs**: 自動ドキュメント生成

## 5. テストカバレッジとメトリクス

### 5.1 カバレッジ目標

個人開発プロジェクトであることを考慮し、現実的な目標を設定します：

- **ユーティリティ関数**: 80%以上
- **カスタムフック**: 70%以上
- **共通UIコンポーネント**: 60%以上
- **ページコンポーネント**: テストの費用対効果が高い部分のみ

### 5.2 カバレッジレポート

- Vitestの組み込みカバレッジツールを使用
- CI/CDパイプラインでカバレッジレポートを生成
- カバレッジ結果の視覚化

### 5.3 テスト品質メトリクス

- **実行時間**: テストスイート全体で1分以内を目標
- **フレーキーテスト**: 不安定なテストの検出と修正
- **コードスメル**: 複雑すぎるテストの検出

## 6. テスト自動化と継続的インテグレーション

### 6.1 ローカル開発環境

- **ウォッチモード**: 開発中の継続的なテスト実行
- **pre-commit フック**: コミット前のテスト実行
- **エディタ統合**: VS Codeプラグインによるテスト実行と結果表示

### 6.2 CI環境（GitHub Actions）

- **Pull Requestごとのテスト**: PRのたびに自動テスト実行
- **マスターブランチ保護**: テスト失敗時のマージブロック
- **テスト結果の可視化**: GitHub上でのテスト結果表示

### 6.3 デプロイパイプライン

- **テスト成功後のデプロイ**: 自動テスト成功時のみデプロイ
- **Storybook静的ビルド**: Storybookの自動デプロイ
- **テスト証跡の保存**: テスト結果の履歴保存

## 7. テスト実装ロードマップ

### 7.1 フェーズ1: 基盤整備

- テスト環境のセットアップ（Vitest, React Testing Library）
- Storybook環境のセットアップ
- 基本的なテストユーティリティと共通モックの実装
- CIパイプラインの構築

### 7.2 フェーズ2: コア機能テスト

- 重要なユーティリティ関数のテスト実装
- カスタムフックのテスト実装
- 基本UIコンポーネント（ボタン、カード等）のストーリー作成

### 7.3 フェーズ3: 拡張機能テスト

- 複合コンポーネントのテスト実装
- ページコンポーネントの重要部分のテスト
- インタラクションテストの追加

### 7.4 フェーズ4: 最適化と拡充

- テストカバレッジ分析と拡充
- パフォーマンス最適化
- Storybookドキュメントの充実化

## 8. テスト導入の課題と対策

### 8.1 想定される課題

- **時間的制約**: 個人開発におけるテスト実装のための時間確保
- **テスト難易度**: Next.js App Router、Server Componentsなどの新機能のテスト
- **メンテナンスコスト**: テスト資産の維持に必要な負担

### 8.2 対策

- **段階的な導入**: 重要度の高い部分から順にテスト導入
- **テストテンプレート**: 繰り返し使えるテストパターンの作成
- **定期的な見直し**: 不要または維持コストの高いテストの定期的な見直し

## 9. テストドキュメント管理

### 9.1 テスト関連ドキュメント

- テストガイドライン（このドキュメント）
- テストパターン集（よくあるテストケースのサンプル）
- トラブルシューティングガイド

### 9.2 知識共有

- テスト関連のナレッジベースの構築
- 効果的なテスト手法のメモ化
- 将来の開発者（自分自身含む）のための引継ぎドキュメント

## 7.5 テスト言語の制約

すべてのテストケースとコードコメントは日本語で記述することを基本方針とします。これには以下が含まれます：

- **テスト関数の説明**: `describe`や`it`内のテスト説明文
- **コード内コメント**: テストコード内の実装解説
- **エラーメッセージ**: テスト内で使用するエラーメッセージ
- **ドキュメンテーション**: テストに関連するすべてのドキュメント

ただし、変数名やメソッド名などのコード要素は英語で記述し、コードの可読性と国際的な標準に準拠します。

この制約を厳格に守ることで、プロジェクト全体の一貫性と可読性を高めます。

## 付録A: Vitestテスト実装例

以下は、典型的なVitestテスト実装の例です：

### ユーティリティ関数のテスト

```typescript
// formatDate関数のテスト例（実装例）
import { describe, it, expect } from 'vitest';
import { formatDate } from './format-date';

describe('formatDate関数', () => {
  it('YYYYMMDDフォーマットで日付をフォーマットする', () => {
    // 準備
    const date = new Date('2023-01-15');
    // 実行
    const result = formatDate(date, 'YYYYMMDD');
    // 検証
    expect(result).toBe('20230115');
  });
  
  it('デフォルトフォーマットを使用する場合、YYYY-MM-DD形式で返す', () => {
    // 準備
    const date = new Date('2023-01-15');
    // 実行
    const result = formatDate(date);
    // 検証
    expect(result).toBe('2023-01-15');
  });
  
  it('無効な日付の場合はエラーをスローする', () => {
    // 実行と検証を一度に行う
    expect(() => formatDate('無効な日付' as any)).toThrow('有効な日付を指定してください');
  });
});
```

### カスタムフックのテスト

```typescript
// useThemeフックのテスト例（実装例）
import { renderHook, act } from '@testing-library/react';
import { useTheme } from './use-theme';
import { ThemeProvider } from 'next-themes';

describe('useThemeフック', () => {
  it('テーマを切り替える機能が正しく動作する', () => {
    // 準備：テスト用のラッパーコンポーネント
    const Wrapper = ({ children }) => (
      <ThemeProvider attribute="class" defaultTheme="light">
        {children}
      </ThemeProvider>
    );
    
    // 実行：フックをレンダリング
    const { result } = renderHook(() => useTheme(), { wrapper: Wrapper });
    
    // 検証：初期状態はlightテーマ
    expect(result.current.theme).toBe('light');
    
    // 実行：テーマ切替関数を呼び出し
    act(() => {
      result.current.toggleTheme();
    });
    
    // 検証：テーマがdarkに変更されたことを確認
    expect(result.current.theme).toBe('dark');
  });
});
```

### コンポーネントのテスト

```typescript
// Buttonコンポーネントのテスト例（実装例）
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './button';

describe('Buttonコンポーネント', () => {
  it('ボタンテキストが正しく表示される', () => {
    // 準備と実行
    render(<Button>クリックしてください</Button>);
    
    // 検証
    expect(screen.getByRole('button', { name: /クリックしてください/i })).toBeInTheDocument();
  });
  
  it('クリックイベントが正しく処理される', () => {
    // 準備：クリックハンドラのモック関数
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>クリックしてください</Button>);
    
    // 実行：ボタンをクリック
    fireEvent.click(screen.getByRole('button'));
    
    // 検証：クリックハンドラが1回呼び出されたことを確認
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('無効状態のボタンが適切に表示される', () => {
    // 準備と実行
    render(<Button disabled>クリックしてください</Button>);
    
    // 検証：ボタンが無効化されていることを確認
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

## 付録B: Storybook実装例

以下は、典型的なStorybook実装の例です。すべてのストーリーファイルはルートディレクトリの`stories`フォルダに配置し、説明やコメントは日本語で記述します：

### 基本的なストーリー

```typescript
// stories/ui/button.stories.tsx
// ボタンコンポーネントのストーリー
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from '../../src/components/ui/button';

const meta: Meta<typeof Button> = {
  title: 'UI/ボタン',
  component: Button,
  parameters: {
    layout: 'centered',
  },
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['default', 'primary', 'secondary', 'outline'],
      description: 'ボタンのバリエーション',
    },
    size: {
      control: { type: 'select' },
      options: ['sm', 'md', 'lg'],
      description: 'ボタンのサイズ',
    },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const デフォルト: Story = {
  args: {
    children: 'ボタン',
  },
};

export const プライマリ: Story = {
  args: {
    variant: 'primary',
    children: 'プライマリボタン',
  },
};

export const セカンダリ: Story = {
  args: {
    variant: 'secondary',
    children: 'セカンダリボタン',
  },
};

export const 小サイズ: Story = {
  args: {
    size: 'sm',
    children: '小さいボタン',
  },
};

export const 大サイズ: Story = {
  args: {
    size: 'lg',
    children: '大きいボタン',
  },
};

export const 無効状態: Story = {
  args: {
    disabled: true,
    children: '無効ボタン',
  },
};
```

### インタラクションテストを含むストーリー

```typescript
// stories/ui/accordion.stories.tsx
// アコーディオンコンポーネントのストーリー（インタラクションテスト付き）
import type { Meta, StoryObj } from '@storybook/react';
import { within, userEvent } from '@storybook/testing-library';
import { expect } from '@storybook/jest';
import { Accordion } from '../../src/components/ui/accordion';

const meta: Meta<typeof Accordion> = {
  title: 'UI/アコーディオン',
  component: Accordion,
  parameters: {
    layout: 'centered',
  },
};

export default meta;
type Story = StoryObj<typeof Accordion>;

export const デフォルト: Story = {
  args: {
    items: [
      {
        title: 'セクション1',
        content: 'セクション1の内容です。',
      },
      {
        title: 'セクション2',
        content: 'セクション2の内容です。',
      },
    ],
  },
};

export const インタラクションテスト: Story = {
  args: {
    ...デフォルト.args,
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // 最初はコンテンツが非表示であることを確認
    const naiyou = canvas.queryByText('セクション1の内容です。');
    await expect(naiyou).not.toBeVisible();
    
    // セクションタイトルをクリック
    const midashi = canvas.getByText('セクション1');
    await userEvent.click(midashi);
    
    // クリック後、コンテンツが表示されることを確認
    await expect(canvas.getByText('セクション1の内容です。')).toBeVisible();
  },
};
```

### レスポンシブデザインのテスト

```typescript
// stories/ui/card.stories.tsx
// カードコンポーネントのストーリー（レスポンシブ表示テスト）
import type { Meta, StoryObj } from '@storybook/react';
import { Card } from '../../src/components/ui/card';

const meta: Meta<typeof Card> = {
  title: 'UI/カード',
  component: Card,
  parameters: {
    layout: 'centered',
    viewport: {
      defaultViewport: 'responsive',
    },
  },
};

export default meta;
type Story = StoryObj<typeof Card>;

export const 基本カード: Story = {
  args: {
    title: 'カードタイトル',
    description: 'カードコンポーネントの説明文です。',
    image: '/placeholder.jpg',
  },
};

export const モバイル表示: Story = {
  ...基本カード,
  parameters: {
    viewport: {
      defaultViewport: 'mobile1',
    },
  },
};

export const タブレット表示: Story = {
  ...基本カード,
  parameters: {
    viewport: {
      defaultViewport: 'tablet',
    },
  },
};

export const デスクトップ表示: Story = {
  ...基本カード,
  parameters: {
    viewport: {
      defaultViewport: 'desktop',
    },
  },
};
```
