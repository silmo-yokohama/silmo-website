# SilMoポートフォリオサイト システム設計ドキュメント

## 1. アプリケーションアーキテクチャ

### 1.1 全体アーキテクチャ

```text
+--------------------+     +--------------------+     +--------------------+
|                    |     |                    |     |                    |
|   クライアント      |<--->|   Next.js アプリ    |<--->|   Newt (CMS)       |
|   (ブラウザ)        |     |   (Vercel)        |     |                    |
|                    |     |                    |     |                    |
+--------------------+     +--------------------+     +--------------------+
                                    ^
                                    |
                                    v
                           +--------------------+
                           |                    |
                           |   Google Analytics |
                           |                    |
                           +--------------------+
```

### 1.2 アーキテクチャの特徴

- **JAMstackアーキテクチャ**: 静的生成（SSG）を基本としつつ、必要に応じてISRを活用
- **ヘッドレスCMS連携**: API経由でコンテンツを取得し、ビルド時に静的ページを生成
- **サーバーサイドレンダリング（SSR）**: 一部ページでは必要に応じてSSRを活用
- **React Server Components (RSC)**: Next.js App Routerの特性を活かした効率的なレンダリング
- **エッジ最適化**: Vercelのエッジネットワークを活用したコンテンツ配信

## 2. ディレクトリ構成

```text
src/
├── app/                     # App Router ディレクトリ
│   ├── (routes)/            # グループ化されたルート
│   │   ├── about/           # /about ページ
│   │   ├── works/           # /works ページ
│   │   │   ├── page/[page]/ # ページネーション
│   │   │   └── [slug]/      # 個別詳細ページ
│   │   ├── sandbox/         # /sandbox ページ
│   │   │   ├── page/[page]/ # ページネーション
│   │   │   └── [slug]/      # 個別詳細ページ
│   │   └── contact/         # /contact ページ
│   ├── api/                 # API ルート
│   │   ├── og/              # 動的OGP生成API
│   │   └── revalidate/      # ISR再検証API
│   ├── globals.css          # グローバルスタイル
│   ├── layout.tsx           # ルートレイアウト
│   └── page.tsx             # ホームページ
├── components/              # コンポーネント
│   ├── ui/                  # shadcn/uiコンポーネント
│   ├── layout/              # レイアウト関連コンポーネント
│   │   ├── header.tsx
│   │   ├── footer.tsx
│   │   └── sidebar.tsx
│   ├── common/              # 共通コンポーネント
│   │   ├── card.tsx
│   │   ├── pagination.tsx
│   │   └── ...
│   ├── works/               # 実績関連コンポーネント
│   ├── sandbox/             # 成果物関連コンポーネント
│   └── about/               # プロフィール関連コンポーネント
├── hooks/                   # カスタムフック
│   ├── use-theme.ts
│   ├── use-scroll.ts
│   └── ...
├── lib/                     # ユーティリティ関数
│   ├── newt.ts              # Newt CMS連携
│   ├── analytics.ts         # GA連携
│   └── utils.ts             # 汎用ユーティリティ
├── styles/                  # スタイル関連
│   └── theme.ts             # テーマ設定
├── types/                   # 型定義
│   ├── cms.ts               # CMS関連の型
│   ├── common.ts            # 共通の型
│   └── ...
└── public/                  # 静的ファイル
    ├── fonts/               # フォントファイル
    ├── images/              # 画像ファイル
    └── ...
```

## 3. コンポーネント設計

### 3.1 基本方針

- **原子設計（Atomic Design）**: UI要素を段階的に組み合わせるコンポーネント設計手法を採用
- **コンポーネント単位の責任分離**: 各コンポーネントは単一の責務を持つよう設計
- **プレゼンテーショナルとコンテナの分離**: データ取得とUI表示の責務を分離
- **Props Drilling回避**: 深いコンポーネント階層でのprops伝播を避けるため、Context APIを適宜活用

### 3.2 主要コンポーネント

#### レイアウトコンポーネント
- `RootLayout`: アプリ全体のレイアウト。Providerやグローバルスタイルを含む
- `Header`: ナビゲーションメニューやブランド要素を含むヘッダー
- `Footer`: サイト共通のフッター情報
- `Container`: コンテンツの配置を制御するコンテナ

#### 実績・成果物関連コンポーネント
- `WorkCard`: 実績・成果物のカード表示コンポーネント
- `WorkGrid`: カードのグリッドレイアウト
- `WorkDetail`: 詳細ページのレイアウト
- `TechBadge`: 使用技術タグの表示
- `Pagination`: ページネーション制御

#### プロフィール関連コンポーネント
- `ProfileSection`: プロフィール情報のセクション
- `SkillChart`: スキルセットのグラフィカル表示
- `TimelineItem`: 経歴表示のタイムライン要素

#### UI共通コンポーネント
- shadcn/uiから提供されるコンポーネント（Button, Card, Input, etc.）
- `ThemeToggle`: ダークモード切替ボタン
- `Animation`: アニメーション効果を適用するラッパー

### 3.3 コンポーネント再利用戦略

- `lib/utils.ts`に共通のヘルパー関数を定義
- `hooks/`ディレクトリに再利用可能なカスタムフックを配置
- スタイルの再利用はTailwind CSSのユーティリティクラスとカスタムクラスを併用

## 4. データフロー設計

### 4.1 データフローパターン

```
+-------------+     +-------------+     +-------------+
|             |     |             |     |             |
| Newt CMS    |---->| Next.js API |---->| React       |
| (データソース) |     | (データ取得)  |     | (表示層)    |
|             |     |             |     |             |
+-------------+     +-------------+     +-------------+
```

### 4.2 データ取得方法

**ビルド時データ取得 (SSG)**
- `getStaticProps`相当の処理をページコンポーネントで実行
- ビルド時にNewtからデータを取得し、静的ページを生成

**インクリメンタル静的再生成 (ISR)**
- 更新頻度が低いデータに対して適用
- 一定期間キャッシュし、バックグラウンドで定期的に再検証

**クライアントサイドデータ取得**
- インタラクティブな要素（検索、フィルタリングなど）で使用
- SWRライブラリを使用した効率的なデータフェッチとキャッシュ

### 4.3 状態管理

- **ローカル状態**: Reactの`useState`フックを使用
- **共有状態**: React Context APIを使用
- **複雑な状態管理**: 必要に応じてZustandを導入
- **フォーム状態**: React Hook Formを使用したフォーム管理

### 4.4 データ変換

- CMS APIから取得したデータは、型安全な形に変換してから使用
- データ構造の変換・加工は`lib/`内のユーティリティ関数に集約

## 5. レンダリング戦略

### 5.1 基本方針

- **Static Site Generation (SSG)**: 基本的にはビルド時に静的ページを生成
- **Incremental Static Regeneration (ISR)**: 更新頻度が低いコンテンツに適用
- **Server Components**: App Routerの特性を活かしたサーバーサイドレンダリング

### 5.2 ページ別レンダリング戦略

| ページ | レンダリング戦略 | 再検証間隔 | 理由 |
|-------|-----------------|-----------|------|
| ホーム | SSG | - | 更新頻度が低いため |
| プロフィール | SSG | - | 頻繁に更新しないコンテンツのため |
| 実績一覧 | ISR | 1時間 | 定期的に追加される可能性があるため |
| 実績詳細 | ISR | 1時間 | 内容が更新される可能性があるため |
| 成果物一覧 | ISR | 1時間 | 定期的に追加される可能性があるため |
| 成果物詳細 | ISR | 1時間 | 内容が更新される可能性があるため |
| お問い合わせ | SSG | - | フォーム送信はクライアントサイドで処理 |

### 5.3 レンダリング最適化

- **Next.js Image**: 画像の最適化によるCLS防止
- **React Suspense**: データ取得中の表示制御
- **レイジーロード**: 画面外コンテンツの遅延読み込み
- **プリフェッチ**: ユーザー行動予測に基づく事前読み込み

## 6. API設計

### 6.1 Newt CMS API連携

#### プロフィール取得

Newt CMSからプロフィール情報を取得するための関数を実装します。特定のアプリと モデルからプロフィールデータを取得し、型安全な形で返す設計とします。

#### 実績/成果物一覧取得

カテゴリ（works/sandbox）、ページネーション、表示件数を指定して、実績/成果物の一覧をNewtから取得する関数を用意します。作成日の降順でソートし、総件数や現在のページ情報も含めたレスポンスを返します。

#### 実績/成果物詳細取得

スラッグ（URL用のID）をパラメータとして、特定の実績/成果物の詳細情報をNewtから取得する関数を実装します。該当データが存在しない場合は適切にnullを返します。

### 6.2 内部API

#### OGP画像生成API

Vercelの@vercel/ogを使用して、動的にOGP画像を生成するAPIエンドポイントを実装します。ページタイトルをパラメータとして受け取り、ブランドカラーを背景にしたカスタムOGP画像を生成します。エッジランタイムで動作させることで、高速なレスポンスを確保します。

#### ISR再検証API

コンテンツ更新時にISRページを再検証するためのAPIエンドポイントを実装します。シークレットキーによる認証を行い、指定されたパスのページを再検証します。Webhookと連携することで、CMS更新時に自動で関連ページを更新する仕組みを構築します。

## 7. 状態管理設計

### 7.1 状態の分類

| 状態の種類 | 管理方法 | 用途 |
|-----------|---------|------|
| UI状態 | React `useState` | ドロップダウン、モーダル、アコーディオン等のUI状態 |
| テーマ状態 | next-themes + Context API | ダークモード/ライトモード切替 |
| フォーム状態 | React Hook Form | お問い合わせフォーム等の入力管理 |
| 永続的状態 | localStorage + Zustand | ユーザー設定など |
| サーバー状態 | SWR | APIから取得したデータのキャッシュと再検証 |

### 7.2 テーマ管理実装

next-themesライブラリを使用して、ダークモード/ライトモードの状態管理を行います。テーマ切替機能をカスタムフックとして実装し、コンポーネント間で再利用できるようにします。また、クライアントサイドのみで動作するよう適切にマウント状態を管理する設計とします。

## 8. エラーハンドリング

### 8.1 エラー処理戦略

- **バウンダリ**: React Error Boundaryを使用したコンポーネントレベルのエラー捕捉
- **非同期エラー**: tryブロックでのAPI呼び出しエラー捕捉
- **フォーム検証**: React Hook Formによる入力検証と適切なエラーメッセージ表示
- **フォールバック**: エラー発生時の代替UI表示

### 8.2 エラーバウンダリ実装

React Componentを拡張したErrorBoundaryコンポーネントを作成します。子コンポーネントでエラーが発生した場合に、それをキャッチしてフォールバックUIを表示する機能を持たせます。プロパティとして、エラー発生時に表示するフォールバックコンポーネントと、通常表示する子コンポーネントを受け取る設計とします。

### 8.3 Loading状態の処理

React SuspenseとNext.js App Routerの機能を組み合わせて、データ読み込み中のローディング状態を適切に処理します。各ページやコンポーネントにスケルトンUI（ローディングプレースホルダー）を用意し、データ取得完了までユーザーにビジュアルフィードバックを提供します。

## 9. パフォーマンス最適化戦略

### 9.1 基本最適化

- **コード分割**: Next.jsのダイナミックインポートによるコード分割
- **画像最適化**: Next.js Imageコンポーネントによる画像サイズ・フォーマット最適化
- **フォント最適化**: next/fontによるWebフォント最適化とCLS対策
- **重要度に基づくリソース読み込み**: `<link rel="preload">`の活用

### 9.2 コードレベルの最適化

- **メモ化**: React.memo、useMemo、useCallbackによる不要な再レンダリング防止
- **仮想スクロール**: 必要に応じてReact Virtualizeなどの仮想リスト表示
- **スケルトンUI**: データ読み込み中の視覚的フィードバック

### 9.3 キャッシュ戦略

- **ISR**: 静的ページの定期的再生成によるデータ鮮度確保
- **SWR**: クライアントサイドでのデータキャッシュと再検証
- **Service Worker**: オフライン対応（必要に応じて）

### 9.4 計測・モニタリング

- **Lighthouse CI**: パフォーマンス指標の継続的測定
- **Web Vitals**: Core Web Vitalsの測定とGA連携
- **エラーモニタリング**: Vercel Analytics活用

## 10. セキュリティ対策

### 10.1 基本対策

- **HTTPSの強制**: Vercelによる自動HTTPS適用
- **CSP (Content Security Policy)**: 適切なCSPヘッダー設定
- **環境変数の管理**: 機密情報の環境変数化とGitからの除外

### 10.2 フォーム対策

- **入力検証**: クライアント・サーバー両方での入力検証
- **レート制限**: お問い合わせフォーム送信の制限
- **CSRF対策**: Newtフォーム送信における適切なトークン管理

### 10.3 API保護

- **APIシークレット**: 再検証APIなどの保護
- **トークン暗号化**: 必要に応じたトークンの安全な管理