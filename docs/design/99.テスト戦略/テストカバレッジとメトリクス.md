# SilMoポートフォリオサイト テストカバレッジとメトリクス

## 1. カバレッジ目標

個人開発プロジェクトであることを考慮し、現実的なカバレッジ目標を設定します：

### 1.1 対象別のカバレッジ目標

- **ユーティリティ関数**: 80%以上
- **カスタムフック**: 70%以上
- **共通UIコンポーネント**: 60%以上
- **ページコンポーネント**: テストの費用対効果が高い部分のみ

### 1.2 カバレッジの種類

- **ステートメントカバレッジ**: コード内のステートメントの実行割合
- **ブランチカバレッジ**: 条件分岐の実行割合
- **関数カバレッジ**: 関数の呼び出し割合
- **行カバレッジ**: コード行の実行割合

## 2. カバレッジレポート

### 2.1 Vitestカバレッジ設定

Vitestの組み込みカバレッジツールを使用して、テストカバレッジを測定します：

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    // ... 他の設定 ...
    coverage: {
      provider: 'c8', // または 'istanbul'
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',
      exclude: [
        'node_modules/',
        '.storybook/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/index.ts',
        'test/**',
      ],
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
});
```

### 2.2 カバレッジレポートの表示

テスト実行時にカバレッジレポートを表示するコマンド：

```bash
# package.json
{
  "scripts": {
    "test": "vitest run",
    "test:coverage": "vitest run --coverage"
  }
}
```

### 2.3 CI/CDパイプラインとの統合

GitHub Actionsなどの CI/CD パイプラインでカバレッジレポートを生成し、結果を保存します：

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run test:coverage
      - name: Upload coverage reports
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: coverage/
```

## 3. テスト品質メトリクス

テストの品質を評価するための指標として、以下のメトリクスを使用します：

### 3.1 テスト実行時間

- **目標**: テストスイート全体で1分以内
- **監視方法**: テスト実行時間のログ記録と継続的なモニタリング
- **改善策**: 遅いテストの特定と最適化、並列実行の活用

```bash
# テスト実行時間の計測
time npm run test
```

### 3.2 フレーキーテスト

不安定なテスト（実行ごとに結果が変わるテスト）を検出し、修正します：

- **検出方法**: 同じテストを複数回実行して結果を比較
- **主な原因**: タイミング依存、外部依存、ランダム値、並列実行の競合
- **対策**: タイムアウトの調整、適切なモック、テスト分離の改善

```bash
# フレーキーテストの検出
npm run test -- --repeat 10 --grep "特定のテスト"
```

### 3.3 コードスメル

テストコードの品質を低下させる「コードスメル」を検出します：

- **長すぎるテスト**: 単一テストが多すぎる検証を行っている
- **複雑すぎるセットアップ**: テスト準備が複雑で理解しにくい
- **脆弱なテスト**: 実装の小さな変更で頻繁に失敗するテスト
- **重複するテスト**: 同じ機能を検証する複数のテスト

対策:
- テストケースの分割と集中
- セットアップコードの共通化と抽象化
- テスト対象の振る舞いに焦点を当てたテスト設計
- テストスイートの定期的な見直しとリファクタリング

## 4. カバレッジレポートの活用方法

### 4.1 開発プロセスへの統合

- **プルリクエスト前のローカルテスト**: コミット前に開発者がローカルでカバレッジを確認
- **PRレビュー時のカバレッジ確認**: レビュープロセスの一部としてカバレッジを評価
- **カバレッジ低下の防止**: 新機能追加時にカバレッジが低下しないよう監視

### 4.2 カバレッジの視覚化

HTML形式のカバレッジレポートを使用して、コードのどの部分がテストされていないかを視覚的に把握：

![カバレッジレポートのイメージ](../assets/coverage-report-example.png)

### 4.3 カバレッジブロッカーの設定（オプション）

重要なモジュールにおいては、最小カバレッジを満たさない場合にビルドを失敗させるブロッカーを設定することも検討します：

```typescript
// vitest.config.ts の一部
coverage: {
  // ... 他の設定 ...
  thresholds: {
    lines: 70,
    functions: 70,
    branches: 70,
    statements: 70,
  },
}
```

## 5. カバレッジ向上のためのベストプラクティス

### 5.1 テストファーストの習慣

- 新機能実装前にテストを記述
- テスト駆動開発（TDD）の考え方を部分的に取り入れる

### 5.2 テストしやすいコード設計

- 単一責任の原則に従ったコンポーネント設計
- 副作用の分離と明示的な依存関係
- 純粋関数の活用

### 5.3 継続的なカバレッジ改善

- テストが不足している領域を定期的に特定
- リファクタリング時にテストを追加
- 新しいバグが見つかった際には、再発防止のためのテストを追加 